# AdventOfCode2022
A repository to hold my solutions to the advent of code puzzles for the year 2022. I think I will create solutions in C++ or C# for most puzzles when the difficulty starts to rise, and maybe do some of the easier days again in some other languages to get a little more comfortable with the syntax. That or I may embrace the python life style.

# Challenges For This Year
- [ ] Complete all 25 challenge days. Due by the 1st of January.
- [ ] Use assembly to solve at least one problem part. Can be done in another language first.
- [ ] Use a brand new language or one I've had minimal interaction with (< 2 hours experience).
- [x] Complete one part in a single line of code (a list of linq queries is acceptable, I just can't make anything new really).
- [ ] Try to visualise one problem in VR or a data graph.

# Day One (C++)
Today I have visitors from Scotland, so my plan of using assembly on the first day is a bit shot for now. As I'd need more time to really get to grips with the very basics I'd need for this challenge. 
I may come back to do the first part at least in assembly later, as it's one of my goals to achieve for this year.

For now, this showed me it's been a while since I've wrote C++ as the file loading seemed an immediate pain, which made me re-use the InputGrabber class I made for AOC two years ago.

# Day Two (C#)
I completed the first part of the problem in one line, purely because of the challenges above. Boi was that a horrible line. More magical than the Harry Potter series.
The second one still uses some ugly ASCII maths, but hey, at least it's out the way quickly.

# Day Three (C#)
Today I embraced the LINQ life. It kind of hurts to know how little care I put into performance, but at least for now performance isn't critical for these tasks. So it's not the worst. 
Definitely doesn't feel like I'm making good use of the Sustainable Software Engineering talks I just attended.

# Day Four (C#)
Could have done both parts in one loop, but the dataset is still really small, so two separate Counts is definitely okay to go for instead.
Today's was really easy, so I probably should have done today's in a different language. Oh well. Mistakes were made.

# Day Five (C#)
The problem itself was really simple, but parsing the input text was a bit more annoying today. 
I'm sure there must be other nice reading ways to do this, but the whole solution to me was just: `Stack`.

# Day Six (C#)
I should really start to use other languages before the puzzles get more difficult. This would have been a great one to quickly do in another language.. But no. I used C# because I was lazy and wanted to get it out the way for the day. Likewise with my other challenges, it's only going to get more difficult if I don't start soon for it.

# Day Seven (C#)
Day seven was another simple to do one, but tedious to setup. I think tomorrow during the national holiday I may visualise this one, as it feels like a nice one to show in a tree building like fashion.
Edit: Visualisation needs to wait for another day, as the holiday has now been claimed to visit my partner's family.

# Day Eight (C#)
I don't think I went about this the best way. But I guess it's clear at this point I never think I've gone the right way with a solution for AoC, even if it completes pretty instantly.
Today since this was completed on a train, I've not taken any time at all to clean it. So there is probably easy to fix segments.

# Day Nine (C#)
This one wasn't as bad as I was expecting it to be. Part two required just extending my solution slightly to work for both parts which was nice. Initially I thought that was going to result in a much bigger change. I'm interested to see what weird and nice mathematical ways people come up with to solve today's puzzle. Doing it interatively was the only thing that came to mind for me... Ohhh. Unless I'd done a Sonic companion like approach where I use the same inputs delayed for the following knots, as opposed to stopping the head for each single step. That seems like more effort though.

# Day Ten (C#)
The only struggle I had with today's puzzle was actually reading it. The logic itself is easy to follow, but how it was worded threw my brain for a loop today. Made 3 or 4 small errors in a row until I read through it all again. Mein Gehirn ist kaputt.

# Day Eleven (C#)
Some real monkey business going on here.... I'll see myself out.
Today was the first day I needed to find a hint for the part 2 solution. In hindsight it was pretty obvious, but isn't something that I need generally in life, so it completely stumped me.

# Day Twelve (C#)
Simple mapping exercise. Reminds me of some old coursework at uni in first or second year. Used a hashset instead of a list of nodes to check, purely to try stop processing the same node twice. Didn't compare timings on this approach though, so List may have been faster. Either way it's pretty instant again, so no harm, no foul.
